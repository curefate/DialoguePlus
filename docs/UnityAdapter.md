# DialoguePlus Unity Adapter

**This file is generated by Claude.**

The **DialoguePlus Unity Adapter** provides a Unity integration layer for the DialoguePlus Core library.

## Features

- **Singleton Access** - Persistent `DialoguePlusAdapter` for accessing compiler, executer, and runtime
- **Automatic Function Registration** - Use `[DPFunction]` attribute to register C# methods callable from scripts
- **Unity-Friendly API** - Async/await support and GameObject integration

## Installation

### Option 1: From Releases (Recommended)

1. Download the latest `.unitypackage` from [Releases](https://github.com/curefate/DialoguePlus/releases)
2. In Unity, go to **Assets → Import Package → Custom Package**
3. Select the downloaded `.unitypackage` file
4. Click **Import**

### Option 2: Manual Installation

1. Download or clone the repository
2. Copy the `adapters/Unity` folder to your Unity project's `Packages` folder
3. Unity will automatically detect and import the package

### Option 3: Add via Package Manager (Git Subfolder)

If you want to use git directly:

1. Open **Window → Package Manager**
2. Click **+** → **Add package from git URL**
3. Enter: `https://github.com/curefate/DialoguePlus.git?path=/adapters/Unity`
4. Click **Add**


## Quick Start

### 1. Access the Adapter

The adapter is a singleton that persists across scenes:

```csharp
// Access anywhere in your code
var adapter = DialoguePlusAdapter.Instance;
var runtime = adapter.Runtime;
var executer = adapter.Executer;
```

### 2. Set Up Callbacks

Override the default dialogue and menu handlers:

```csharp
using UnityEngine;
using DialoguePlus.Core;
using System.Threading.Tasks;

public class DialogueController : MonoBehaviour
{
    void Start()
    {
        var executer = DialoguePlusAdapter.Instance.Executer;
        
        // Handle dialogue display
        executer.OnDialogueAsync = async (runtime, dialogue) =>
        {
            string speaker = dialogue.Speaker;
            string text = dialogue.Text.Evaluate(runtime);
            
            // Display in your UI
            Debug.Log($"{speaker}: {text}");
            
            // Wait for player input
            await WaitForInput();
        };
        
        // Handle menu choices
        executer.OnMenuAsync = async (runtime, menu) =>
        {
            // Show options to player
            // Return selected index (0-based)
            return await ShowMenuAndGetChoice(menu);
        };
    }
    
    private async Task WaitForInput()
    {
        while (!Input.GetMouseButtonDown(0))
            await Task.Yield();
    }
    
    private async Task<int> ShowMenuAndGetChoice(SIR_Menu menu)
    {
        // Your menu UI logic here
        return 0; // Return selected option index
    }
}
```

### 3. Execute Scripts

```csharp
public async void StartStory()
{
    await DialoguePlusAdapter.Instance.ExecuteToEnd("Assets/Scripts/story.dp");
}
```

## Registering Functions

Functions registered with the runtime can be called from D+ scripts using `call` statements.

### Manual Registration

```csharp
void Start()
{
    var runtime = DialoguePlusAdapter.Instance.Runtime;
    
    // Register a simple function
    runtime.Functions.AddFunction(SaveGame, "SaveGame");
    
    // Register with parameters
    runtime.Functions.AddFunction<string>(ShowMessage);
}

void SaveGame() => Debug.Log("Game saved!");
void ShowMessage(string msg) => Debug.Log(msg);
```

**In D+ Script:**
```python
call SaveGame()
call ShowMessage("Hello!")
```

### Attribute-Based Registration (Auto)

Use `[DPFunction]` for automatic registration at runtime:

#### Static Methods

```csharp
public class GameFunctions : MonoBehaviour
{
    [DPFunction]
    public static int RollDice()
    {
        return Random.Range(1, 7);
    }
    
    [DPFunction("playSound")]
    public static void PlaySoundEffect(string soundName)
    {
        // Play sound logic
    }
}
```

**In D+ Script:**
```python
$dice = call RollDice()
call playSound("click")
```

#### Instance Methods

For instance methods, **the first parameter is the GameObject name**:

```csharp
public class Character : MonoBehaviour
{
    [DPFunction]
    public void SetEmotion(string emotion)
    {
        // Change character's emotion
        Debug.Log($"{gameObject.name} is now {emotion}");
    }
}
```

**In D+ Script:**
```python
# First argument is the GameObject name
call SetEmotion("Hero", "happy")
call SetEmotion("Villain", "angry")
```

The adapter automatically:
- Finds the GameObject by name using `GameObject.Find()`
- Gets the component of the declaring type
- Calls the method on that instance

**Supported Types**: `string`, `int`, `float`, `bool` (parameters and return values)

## Sample Scene

A complete example scene is included with the package demonstrating:
- Visual novel-style dialogue system
- Character sprites with animations
- Menu system with choices
- Function registration examples

**To Import:**
1. Open **Package Manager**
2. Find **DialoguePlus** in the list
3. Expand **Samples**
4. Click **Import** next to "DialoguePlus Sample Scene"

The sample includes:
- `ChatManager.cs` - Dialogue and menu UI controller
- `Talker.cs` - Character sprite with `[DPFunction]` methods
- Sample D+ scripts demonstrating syntax and features

## API Reference

### DialoguePlusAdapter

```csharp
public class DialoguePlusAdapter : MonoBehaviour
{
    public static DialoguePlusAdapter Instance { get; }
    public Executer Executer { get; }
    public Runtime Runtime { get; }
    
    public async Task ExecuteToEnd(string path);
}
```

### DPFunction Attribute

```csharp
[DPFunction]                    // Uses method name
[DPFunction("customName")]      // Custom name in scripts
```

**Requirements:**
- Return type: `void`, `string`, `int`, `float`, or `bool`
- Parameters: `string`, `int`, `float`, or `bool` only
- Instance methods: First script parameter is GameObject name (auto-injected)

## Common Patterns

### Accessing Variables from C#

```csharp
var runtime = DialoguePlusAdapter.Instance.Runtime;

// Set variables
runtime.Variables.Set("playerName", "Alice");
runtime.Variables.Set("global.score", 100);

// Get variables
var name = runtime.Variables.Get("playerName").Value;
var score = runtime.Variables.Get("global.score").Value;
```

### Step-by-Step Execution

```csharp
var result = compiler.Compile(path);
if (result.Success)
{
    executer.Prepare(result.Labels);
    
    while (executer.HasNext)
    {
        await executer.StepAsync();
        
        // Check next instruction
        if (executer.Peek() is SIR_Dialogue)
        {
            // Next is dialogue
        }
    }
}
```

## Limitations

- Maximum 5 parameters per function (Core library limitation)
- Only basic types supported: `string`, `int`, `float`, `bool`
- Instance methods require exact GameObject name match
- GameObject must be active in the scene

## Next Steps

- Review [Getting Started](GettingStarted.md) for D+ language basics
- Check [Syntax Guide](Syntax.md) for scripting reference
- See [API Reference](API.md) for core library documentation
- Explore the sample scene for practical examples

## Troubleshooting

**"Function not found"**  
→ Ensure function is registered before executing the script. Check console for `[D+]` registration logs.

**"GameObject not found"** (instance methods)  
→ Verify GameObject name matches exactly and is active in the scene.

**Compilation errors**  
→ Check console for error messages with line numbers. Review [Syntax Guide](Syntax.md) for correct syntax.
lus Unity Adapter

The **DialoguePlus Unity Adapter** bridges the D+ core with Unity’s scene lifecycle and game objects. It provides:

- A lightweight, persistent **singleton** to access default D+ compiler, executer and runtime.
- One‑shot compile‑and‑run convenience API
- Automatic function registration via attributes for both static and instance methods

## Quick Start

- TODO, recommended to refer to the example scene included in the package, you can import it from PackageManager of Unity.
